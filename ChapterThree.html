<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agile software development</title>
</head>
<body>

    <header>
        <h1>3</h1>   
        <h2>Agile softwaredevelopment</h2>

         <section>
            <h3>Objectives</h3>
            <p>The objective of this chapter is to introduce you to agile softwaredevelopment methods. When you have read the chapter, you will:</p>
         </section>

         <section>
            <ul>
                <li>understand the rationale for agile software development methods,the agile manifesto, and the differences between agile and plandriven development;</li>
                <li>know the key practices in extreme programming and how these relate to the general principles of agile methods;</li>
                <li>understand the Scrum approach to agile project management;</li>
                <li>understand the concepts of user stories, story points, and velocity;</li>
                <li>be aware of the issues and problems of scaling agile developmentmethods to the development of large software systems.</li>
            </ul>
        </section>

        <section>
        <h4>Contents</h4>
            <ol>
                <li>3.1 Agile methods</li>
                <li>3.2 Plan-driven and agile development</li>
                <li>3.3 Extreme programming</li>
                <li>3.4 Agile project management</li>
                <li>3.5 Scaling agile methods</li>
            </ol>
        </section>


    </header>

     <aside>
           <img src="" alt="photo">
     </aside>



      

    <main>

        <article>
             <section>
                <p>Chapter 3 ■ Agile software development <strong>57</strong></p>
            </section>

            <section>
               <p>Businesses now operate in a global, rapidly changing environment. They have to respond to new opportunities and markets, changing economic conditions, and the
                 emergence of competing products and services. Software is part of almost all business operations so new software is developed quickly to take advantage of new
                 opportunities and to respond to competitive pressure. Rapid development and delivery is therefore now often the most critical requirement for software systems. In fact,
                 many businesses are willing to trade off software quality and compromise on requirements to achieve faster deployment of the software that they need. 
              </p>

                <p>Because these businesses are operating in a changing environment, it is often practically impossible to derive a complete set of stable software requirements. The initial
                   requirements inevitably change because customers find it impossible to predict how a system will affect working practices, how it will interact with other systems, and what
                   user operations should be automated. It may only be after a system has been delivered and users gain experience with it that the real requirements become clear. Even then,
                  the requirements are likely to change quickly and unpredictably due to external factors.The software may then be out of date when it is delivered.
                </p>

                
                <p>Software development processes that plan on completely specifying the requirements and then designing, building, and testing the system are not geared to rapid software
                    development. As the requirements change or as requirements problems are discovered, the system design or implementation has to be reworked and retested. As a consequence, a conventional waterfall or 
                    specification-based process is usually prolonged and the final software is delivered to the customer long after it was originally specified.
                </p>

                <p>
                   For some types of software, such as safety-critical control systems, where a complete analysis of the system is essential, a plan-driven approach is the right one.
                   However, in a fast-moving business environment, this can cause real problems. By the time the software is available for use, the original reason for its procurement may
                   have changed so radically that the software is effectively useless. Therefore, for business systems in particular, development processes that focus on rapid software
                   development and delivery are essential. 
                </p>

                <p>
                   The need for rapid system development and processes that can handle changing
                   requirements has been recognized for some time. IBM introduced incremental development in the 1980s (Mills et al., 1980). The introduction of so-called fourthgeneration languages, also in the 1980s, supported the idea of quickly developing
                   and delivering software (Martin, 1981). However, the notion really took off in the late 1990s with the development of the notion of agile approaches such as DSDM
                  (Stapleton, 1997), Scrum (Schwaber and Beedle, 2001), and extreme programming (Beck, 1999; Beck, 2000).</p>

               </p>
                  Rapid software development processes are designed to produce useful software quickly. The software is not developed as a single unit but as a series of increments, with
                  each increment including new system functionality. Although there are many
                  approaches to rapid software development, they share some fundamental characteristics:
                </p>
            </section>

            <section>
               <p>
                  1. The processes of specification, design, and implementation are interleaved.There is no detailed 
                  system specification, and design documentation is minimized or generated automatically by the programming environment used to
                </p>
            </section>

            <section>
               <p><strong>58</strong>Chapter 3 ■ Agile software development</p>
            </section>

            <section>
                <p>
                    implement the system. The user requirements document only defines the most important characteristics of the system.
                    <br>2. The system is developed in a series of versions. End-users and other system stakeholders are involved in specifying and evaluating each version. They may
                    propose changes to the software and new requirements that should be implemented in a later version of the system.
                    <br>3. System user interfaces are often developed using an interactive development
                    system that allows the interface design to be quickly created by drawing and placing icons on the interface. The system may then generate a web-based interface for
                    a browser or an interface for a specific platform such as Microsoft Windows.
                    Agile methods are incremental development methods in which the increments are
                    small and, typically, new releases of the system are created and made available to customers every two or three weeks. They involve customers in the development process
                    to get rapid feedback on changing requirements. They minimize documentation by
                    using informal communications rather than formal meetings with written documents.
                </p>

                <p>
                    <br>Agile methods are incremental development methods in which the increments are
                     small and, typically, new releases of the system are created and made available to customers every two or three weeks. They involve customers in the development process
                     to get rapid feedback on changing requirements. They minimize documentation using informal communications rather than formal meetings with written documents.
                </p>
            </section>

            <section>
                <h3>3.1 Agile methods</h3>
            </section>

            <p>
                In the 1980s and early 1990s, there was a widespread view that the best way to achieve better software was through careful project planning, formalized quality
                assurance, the use of analysis and design methods supported by CASE tools, and controlled and rigorous software development processes. This view came from the
                software engineering community that was responsible for developing large, longlived software systems such as aerospace and government systems.
            </p>

            <p>
                This software was developed by large teams working for different companies. Teams were often geographically dispersed and worked on the software for long periods of
                time. An example of this type of software is the control systems for a modern aircraft,
                which might take up to 10 years from initial specification to deployment. These plandriven approaches involve a significant overhead in planning, designing, and documenting the system. This overhead is justified when the work of multiple development teams
                has to be coordinated, when the system is a critical system, and when many different
                people will be involved in maintaining the software over its lifetime.
            </p>

            <p>
                However, when this heavyweight, plan-driven development approach is applied to small and medium-sized business systems, the overhead involved is so large that it
                dominates the software development process. More time is spent on how the system
should be developed than on program development and testing. As the system
requirements change, rework is essential and, in principle at least, the specification
and design has to change with the program.

            </p>

            <p>
                Dissatisfaction with these heavyweight approaches to software engineering led a
number of software developers in the 1990s to propose new ‘agile methods’. These
allowed the development team to focus on the software itself rather than on its design
            </p>

            <section>
                <p>3.1 ■ Agile methods 59</p>
            </section>

            <section>
                <p>
                    and documentation. Agile methods universally rely on an incremental approach to software specification, development, and delivery. They are best suited to application development where the system requirements usually change rapidly during the development
process. They are intended to deliver working software quickly to customers, who can
then propose new and changed requirements to be included in later iterations of the system. They aim to cut down on process bureaucracy by avoiding work that has dubious
long-term value and eliminating documentation that will probably never be used.
                </p>
                 
                <p>
                    The philosophy behind agile methods is reflected in the agile manifesto that was
agreed on by many of the leading developers of these methods. This manifesto states:
                </p>
            </section>

            <section>
                <p>
                    We are uncovering better ways of developing software by doing it and helping
others do it. Through this work we have come to value:
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan
That is, while there is value in the items on the right, we value the items on the
left more
                </p>
            </section>

            <section>
                <p>
                    Probably the best-known agile method is extreme programming (Beck, 1999;
Beck, 2000), which I describe later in this chapter. Other agile approaches include
Scrum (Cohn, 2009; Schwaber, 2004; Schwaber and Beedle, 2001), Crystal
(Cockburn, 2001; Cockburn, 2004), Adaptive Software Development (Highsmith,
2000), DSDM (Stapleton, 1997; Stapleton, 2003), and Feature Driven Development
(Palmer and Felsing, 2002). The success of these methods has led to some integration
with more traditional development methods based on system modelling, resulting in
the notion of agile modelling (Ambler and Jeffries, 2002) and agile instantiations of
the Rational Unified Process (Larman, 2002).
                </p>


                <p>
                    Although these agile methods are all based around the notion of incremental development and delivery, they propose different processes to achieve this. However, they
share a set of principles, based on the agile manifesto, and so have much in common.
These principles are shown in Figure 3.1. Different agile methods instantiate these principles in different ways and I don’t have space to discuss all agile methods. Instead, I
focus on two of the most widely used methods: extreme programming (Section 3.3) and
Scrum (Section 3.4).
                </p>

                 <p>
                    Agile methods have been very successful for some types of system development:
                 </p>
            </section>

            <section>
                <p>
                   1. Product development where a software company is developing a small or
medium-sized product for sale.
                </p>

                <p>
                    2. Custom system development within an organization, where there is a clear commitment from the customer to become involved in the development process and
where there are not a lot of external rules and regulations that affect the software.
                </p>
            
            </section>

            <section>
                <img src="ChapterThree/image.png" alt="">
            </section>

            <section>
                <p>
                    As I discuss in the final section of this chapter, the success of agile methods has
meant that there is a lot of interest in using these methods for other types of software
development. However, because of their focus on small, tightly integrated teams,
there are problems in scaling them to large systems. There have also been experiments in using agile approaches for critical systems engineering (Drobna et al.,
2004). However, because of the need for security, safety, and dependability analysis
in critical systems, agile methods require significant modification before they can be
routinely used for critical systems engineering.
                </p>

                <p>
                    In practice, the principles underlying agile methods are sometimes difficult to realize:
                </p>
            </section>

            <section>
                <p>
                    1. Although the idea of customer involvement in the development process is an
attractive one, its success depends on having a customer who is willing and able
to spend time with the development team and who can represent all system
stakeholders. Frequently, the customer representatives are subject to other pressures and cannot take full part in the software development.
                </p>

                <p>
                    2. Individual team members may not have suitable personalities for the intense
involvement that is typical of agile methods, and therefore not interact well with
other team members.
                </p>

                <p>
                    3. Prioritizing changes can be extremely difficult, especially in systems for which
there are many stakeholders. Typically, each stakeholder gives different priorities to different changes.
                </p>

                <p>
                    4. Maintaining simplicity requires extra work. Under pressure from delivery
schedules, the team members may not have time to carry out desirable system
simplifications.
                </p>
            </section>

            <section>
                <p>3.1 ■ Agile methods 61</p>
            </section>

            <section>
                <p>
                    5. Many organizations, especially large companies, have spent years changing
their culture so that processes are defined and followed. It is difficult for them to
move to a working model in which processes are informal and defined by development teams.
                </p>
            </section>

            <section>
                <p>
                    Another non-technical problem—that is a general problem with incremental
development and delivery—occurs when the system customer uses an outside organization for system development. The software requirements document is usually part
of the contract between the customer and the supplier. Because incremental specification is inherent in agile methods, writing contracts for this type of development
may be difficult.
                </p>

                <p>
                    Consequently, agile methods have to rely on contracts in which the customer pays
for the time required for system development rather than the development of a specific set of requirements. So long as all goes well, this benefits both the customer and
the developer. However, if problems arise then there may be difficult disputes over
who is to blame and who should pay for the extra time and resources required to
resolve the problems.
                </p>

                <p>
                    Most books and papers that describe agile methods and experiences with agile
methods talk about the use of these methods for new systems development.
However, as I explain in Chapter 9, a huge amount of software engineering effort
goes into the maintenance and evolution of existing software systems. There are only
a small number of experience reports on using agile methods for software maintenance (Poole and Huisman, 2001). There are two questions that should be considered when considering agile methods and maintenance:
                </p>
            </section>

            <section>
                <p>
                    1. Are systems that are developed using an agile approach maintainable, given the
emphasis in the development process of minimizing formal documentation?

                </p>

                <p>
                    2. Can agile methods be used effectively for evolving a system in response to customer change requests?
                </p>
            </section>

            <section>
                <p>
                    Formal documentation is supposed to describe the system and so make it easier
for people changing the system to understand. In practice, however, formal documentation is often not kept up to date and so does not accurately reflect the program
code. For this reason, agile methods enthusiasts argue that it is a waste of time to
write this documentation and that the key to implementing maintainable software is
to produce high-quality, readable code. Agile practices therefore emphasize the
importance of writing well-structured code and investing effort in code improvement. Therefore, the lack of documentation should not be a problem in maintaining
systems developed using an agile approach.

                </p>

                <p>
                    However, my experience of system maintenance suggests that the key document
is the system requirements document, which tells the software engineer what the
system is supposed to do. Without such knowledge, it is difficult to assess the impact
of proposed system changes. Many agile methods collect requirements informally
and incrementally and do not create a coherent requirements document. In this
                </p>
            </section>

            <section>
                <p>
                    62 Chapter 3 ■ Agile software development
                </p>
            </section>

            <section>
                <p>
                    respect, the use of agile methods is likely to make subsequent system maintenance
more difficult and expensive.
                </p>

                <p>
                    Agile practices, used in the maintenance process itself, are likely to be effective,
whether or not an agile approach has been used for system development. Incremental
delivery, design for change and maintaining simplicity all make sense when software
is being changed. In fact, you can think of an agile development process as a process
of software evolution.
                </p>

                <p>
                    of software evolution.
However, the main difficulty after software delivery is likely to be keeping customers involved in the process. Although a customer may be able to justify the fulltime involvement of a representative during system development, this is less likely
during maintenance where changes are not continuous. Customer representatives are
likely to lose interest in the system. Therefore, it is likely that alternative mechanisms, such as change proposals, discussed in Chapter 25, will be required to create
the new system requirements.
                </p>

                <p>
                    The other problem that is likely to arise is maintaining continuity of the development team. Agile methods rely on team members understanding aspects of the
system without having to consult documentation. If an agile development team is
broken up, then this implicit knowledge is lost and it is difficult for new team members to build up the same understanding of the system and its components.
                </p>

                <p>
                    Supporters of agile methods have been evangelical in promoting their use and
have tended to overlook their shortcomings. This has prompted an equally extreme
response, which, in my view, exaggerates the problems with this approach (Stephens
and Rosenberg, 2003). More reasoned critics such as DeMarco and Boehm
(DeMarco and Boehm, 2002) highlight both the advantages and disadvantages of
agile methods. They propose a hybrid approach where agile methods incorporate
some techniques from plan-driven development may be the best way forward.
                </p>
            </section>

            <section>
                <h3>3.2 Plan-driven and agile development</h3>
            </section>

            <section>
                <p>
                    Agile approaches to software development consider design and implementation to be
the central activities in the software process. They incorporate other activities, such as
requirements elicitation and testing, into design and implementation. By contrast, a
plan-driven approach to software engineering identifies separate stages in the software process with outputs associated with each stage. The outputs from one stage are
used as a basis for planning the following process activity. Figure 3.2 shows the distinctions between plan-driven and agile approaches to system specification.
                </p>

                <p>
                    In a plan-driven approach, iteration occurs within activities with formal documents used to communicate between stages of the process. For example, the requirements will evolve and, ultimately, a requirements specification will be produced.
This is then an input to the design and implementation process. In an agile approach,
iteration occurs across activities. Therefore, the requirements and the design are
developed together, rather than separately.
                </p>
            </section>

            <section>
                <p>3.2 ■ Plan-driven and agile development 63</p>
            </section>

            <section>
                <img src="ChapterThree/x.png" alt="">
            </section>

            <section>
                <p>
                    A plan-driven software process can support incremental development and delivery. It is perfectly feasible to allocate requirements and plan the design and development phase as a series of increments. An agile process is not inevitably code-focused
and it may produce some design documentation. As I discuss in the following section, the agile development team may decide to include a documentation ‘spike’,
where, instead of producing a new version of a system, the team produce system
documentation.
                </p>

                <p>In fact, most software projects include practices from plan-driven and agile
approaches. To decide on the balance between a plan-based and an agile approach,
you have to answer a range of technical, human, and organizational questions:</p>
            </section>

            <section>
                <p>
                    1. Is it important to have a very detailed specification and design before moving to
implementation? If so, you probably need to use a plan-driven approach.

                </p>

                <p>
                    2. Is an incremental delivery strategy, where you deliver the software to customers
and get rapid feedback from them, realistic? If so, consider using agile methods.
                </p>

                <p>
                    3. How large is the system that is being developed? Agile methods are most effective when the system can be developed with a small co-located team who can
communicate informally. This may not be possible for large systems that require
larger development teams so a plan-driven approach may have to be used.
                </p>

                <p>
                    4. What type of system is being developed? Systems that require a lot of analysis
before implementation (e.g., real-time system with complex timing requirements) usually need a fairly detailed design to carry out this analysis. A plandriven approach may be best in those circumstances.
                </p>

                <p>
                   5. What is the expected system lifetime? Long-lifetime systems may require more
design documentation to communicate the original intentions of the system 
                </p>
            </section>

            <section>
                <p>
                    64 Chapter 3 ■ Agile software development
                </p>
            </section>

            <section>
                <p>
                    developers to the support team. However, supporters of agile methods rightly
argue that documentation is frequently not kept up to date and it is not of much
use for long-term system maintenance.
                </p>

                <p>
                    6. What technologies are available to support system development? Agile methods
often rely on good tools to keep track of an evolving design. If you are developing a system using an IDE that does not have good tools for program visualization and analysis, then more design documentation may be required.
                </p>

                <p>
                    7. How is the development team organized? If the development team is distributed
or if part of the development is being outsourced, then you may need to develop
design documents to communicate across the development teams. You may
need to plan in advance what these are.
                </p>

                <p>
                    8. Are there cultural issues that may affect the system development? Traditional
engineering organizations have a culture of plan-based development, as this is
the norm in engineering. This usually requires extensive design documentation,
rather than the informal knowledge used in agile processes.
                </p>

                <p>
                    9. How good are the designers and programmers in the development team? It is
sometimes argued that agile methods require higher skill levels than plan-based
approaches in which programmers simply translate a detailed design into code.
If you have a team with relatively low skill levels, you may need to use the best
people to develop the design, with others responsible for programming
                </p>

                <p>
                    10. Is the system subject to external regulation? If a system has to be approved by an
external regulator (e.g., the Federal Aviation Authority [FAA] approve software
that is critical to the operation of an aircraft) then you will probably be required
to produce detailed documentation as part of the system safety case.

                </p>
            </section>

            <section>
                <p>
                    In reality, the issue of whether a project can be labelled as plan-driven or agile is
not very important. Ultimately, the primary concern of buyers of a software system
is whether or not they have an executable software system that meets their needs and
does useful things for the individual user or the organization. In practice, many companies who claim to have used agile methods have adopted some agile practices and
have integrated these with their plan-driven processes.
                </p>
            </section>

            <section>
                <h3>3.3 Extreme programming</h3>
            </section>

            <section>
                <p>
                    Extreme programming (XP) is perhaps the best known and most widely used of the
agile methods. The name was coined by Beck (2000) because the approach was
developed by pushing recognized good practice, such as iterative development, to
‘extreme’ levels. For example, in XP, several new versions of a system may be developed by different programmers, integrated and tested in a day.
                </p>
            </section>

            <SEction>
                <P>
                    3.3 ■ Extreme programming 65

                </P>
            </SEction>

            <Section>
               <img src="ChapterThree/stories.png" alt="">
            </Section>

            <section>
                <p>
                    In extreme programming, requirements are expressed as scenarios (called user
stories), which are implemented directly as a series of tasks. Programmers work in
pairs and develop tests for each task before writing the code. All tests must be successfully executed when new code is integrated into the system. There is a short time
gap between releases of the system. Figure 3.3 illustrates the XP process to produce
an increment of the system that is being developed.
                </p>

                <p>
                    Extreme programming involves a number of practices, summarized in Figure 3.4,
which reflect the principles of agile methods:
                </p>
            </section>

            <section>
                <p>
                    1. Incremental development is supported through small, frequent releases of the
system. Requirements are based on simple customer stories or scenarios that are
used as a basis for deciding what functionality should be included in a system
increment.
                </p>

                <p>
                    2. Customer involvement is supported through the continuous engagement of the
customer in the development team. The customer representative takes part in the
development and is responsible for defining acceptance tests for the system.
                </p>

                <p>
                    3. People, not process, are supported through pair programming, collective ownership of the system code, and a sustainable development process that does not
involve excessively long working hours.
                </p>

                <p>
                    4. Change is embraced through regular system releases to customers, test-first
development, refactoring to avoid code degeneration, and continuous integration of new functionality.

                </p>

                <p>
                    5. Maintaining simplicity is supported by constant refactoring that improves code
quality and by using simple designs that do not unnecessarily anticipate future
changes to the system.

                </p>
            </section>

            <section>
                <p>
                    In an XP process, customers are intimately involved in specifying and prioritizing
system requirements. The requirements are not specified as lists of required system
functions. Rather, the system customer is part of the development team and discusses
scenarios with other team members. Together, they develop a ‘story card’ that encapsulates the customer needs. The development team then aims to implement that scenario in a future release of the software. An example of a story card for the mental
                </p>
            </section>

            <section>
                <p>
                    66 Chapter 3 ■ Agile software development
                </p>
            </section>


            <section>
                <img src="ChapterThree/image.png" alt="">
            </section>

            <section>
                <p>
                    health care patient management system is shown in Figure 3.5. This is a short
description of a scenario for prescribing medication for a patient.
                </p>

                <p>
                    The story cards are the main inputs to the XP planning process or the ‘planning
game’. Once the story cards have been developed, the development team breaks these
down into tasks (Figure 3.6) and estimates the effort and resources required for implementing each task. This usually involves discussions with the customer to refine the
requirements. The customer then prioritizes the stories for implementation, choosing
those stories that can be used immediately to deliver useful business support. The
intention is to identify useful functionality that can be implemented in about two
weeks, when the next release of the system is made available to the customer.
                </p>

                <p>
                    Of course, as requirements change, the unimplemented stories change or may be
discarded. If changes are required for a system that has already been delivered, new
story cards are developed and again, the customer decides whether these changes
should have priority over new functionality
                </p>
            </section>

            <section>
                <img src="ChapterThree/p.png" alt="">
            </section>

            <section>
                <p>
                    Sometimes, during the planning game, questions that cannot be easily answered
come to light and additional work is required to explore possible solutions. The team
may carry out some prototyping or trial development to understand the problem and
solution. In XP terms, this is a ‘spike’, an increment where no programming is done.
There may also be ‘spikes’ to design the system architecture or to develop system
documentation.
                </p>

                <p>
                    Extreme programming takes an ‘extreme’ approach to incremental development.
New versions of the software may be built several times per day and releases are
delivered to customers roughly every two weeks. Release deadlines are never
slipped; if there are development problems, the customer is consulted and functionality is removed from the planned release
                </p>

                <p>
                    When a programmer builds the system to create a new version, he or she must run
all existing automated tests as well as the tests for the new functionality. The new
build of the software is accepted only if all tests execute successfully. This then
becomes the basis for the next iteration of the system.
                </p>

                <p>
                    
                </p>
            </section>





        </article>
    </main>
    
</body>
</html>